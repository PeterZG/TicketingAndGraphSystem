
# blog 1

## 迭代器与可迭代对象

### 你认为将图(Graph)设计为可迭代的是否有语义上的意义？简要讨论，并考虑双方的观点。
将图设计为可迭代对象可以方便地遍历它的节点或边。

### 在这种情况下，图是迭代器还是可迭代对象？
它既是迭代器，也是可迭代对象，两者都有效。

### 在这种情况下，.iterator 方法会返回什么？
.iterator 方法将返回图本身。

### 然而，这种方法存在问题。在你的博客中，描述一个会导致该实现失败的测试。
如果图返回自身作为迭代器，那么迭代器之间就不是独立的。一个迭代器调用 next() 会影响到其他迭代器。

## 迭代器失效
graph.removeNode() 会破坏图的迭代器，某些节点如果失去所有边，就无法被访问。

# blog 2

## Q1) 为什么编译器没有警告我代码中存在这个错误？
FlowerBox 类接受 Flower 类型，但没有区分不同的花卉。

## Q2) 为什么我必须强制转换从各自盒子返回的花卉列表？
各自的盒子只是有不同的变量名，它们并不知道实际的类类型。

## Q3) 现在使用泛型的 FlowerBox 时，编译器是否警告或给出错误？为什么？
是的。FlowerBox 的泛型参数与请求不匹配。

## Q4) 编译器提供的信息是如何帮助你修复错误的？为什么在修复错误后，类型系统就不会再报错了？
编译器提示“类型 FlowerBox<Sunflower> 中的 addFlower(Sunflower) 方法不适用于参数（Rose）”。  
修复错误后，类型与参数匹配，问题就解决了。

## Q5) 从 routeHarvest 方法中删除所有强制转换后，这部分代码应该没有警告或错误了。为什么我们现在不需要再进行任何强制转换？
因为类型已经与左侧的类型匹配。

## Q6) 你认为在这里使用泛型而不是为 SunflowerBox 和 RoseBox 创建子类有什么优势？
不同的盒子都有相同的方法，唯一的区别是参数的类型。